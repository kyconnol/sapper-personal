<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <title>Kyle Connolly</title> <base href=/ > <link href=spinnaker.min.css rel=stylesheet> <link href=bootstrap.min.css rel=stylesheet> <link href=https://kit-free.fontawesome.com/releases/latest/css/free.min.css rel=stylesheet media=all> <link href=https://kit-free.fontawesome.com/releases/latest/css/free-v4-font-face.min.css rel=stylesheet media=all> <link href=https://kit-free.fontawesome.com/releases/latest/css/free-v4-shims.min.css rel=stylesheet media=all> <script src=https://kit.fontawesome.com/74f5a748fc.js></script> <script src="https://www.googletagmanager.com/gtag/js?id=UA-181416528-1" async> </script> <script> window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'UA-181416528-1'); </script> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"Creating a multinode Kubernetes cluster from a single Raspberry Pi 4",slug:"rpi-cluster",html:"\u003Ch1 id=\"setup-a-kubernetes-cluster-on-a-single-raspberry-pi-4-using-kvm-and-k3s\"\u003ESetup a Kubernetes cluster on a single Raspberry Pi 4, using \u003Ccode\u003EKVM\u003C\u002Fcode\u003E and \u003Ccode\u003Ek3s\u003C\u002Fcode\u003E\u003C\u002Fh1\u003E\n\u003Ch3 id=\"not-all-tools-just-work-for-soc-systems\"\u003ENot all tools &#39;just work&#39; for SoC systems\u003C\u002Fh3\u003E\n\u003Cp\u003EHaving decided to learn Kubernetes, I purchased a Rasperry Pi 4 (4GB) to create a dedicated machine \u002F cluster to experiment and learn on. I \u003Cem\u003Efigured\u003C\u002Fem\u003E I could use a simple tool to create a few VMs, and create a trivial cluster; however \u003Ccode\u003Emultipass\u003C\u002Fcode\u003E would not spin up VMs on my Pi. I didn&#39;t want to buy another Pi, so I started down the path of creating worker nodes via KVM\u002FQEMU.\u003C\u002Fp\u003E\n\u003Cp\u003EI&#39;d like to share the steps I&#39;ve taken to create (\u003Cem\u003Etechnically\u003C\u002Fem\u003E, perhaps not practically) a Kubernetes cluster with only one Raspberry Pi board.\u003C\u002Fp\u003E\n\u003Ch3 id=\"these-are-the-required-steps-at-a-high-level\"\u003EThese are the required steps, at a high level\u003C\u002Fh3\u003E\n\u003Col\u003E\n\u003Cli\u003EFlash a Micro SD card with Ubuntu Server 19.10 for \u003Ca href=\"http:\u002F\u002Fold-releases.ubuntu.com\u002Freleases\u002F19.10\u002Fubuntu-19.10-preinstalled-server-arm64+raspi3.img.xz\"\u003ERaspberry Pi\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003ESet up the server node (the Raspberry Pi itself)\u003C\u002Fli\u003E\n\u003Cli\u003EHandle k8s-related considerations for the server node\u003Cul\u003E\n\u003Cli\u003Evirtualization, container features, bridged networking\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003EInstall VMs via \u003Ccode\u003Evirt-install\u003C\u002Fcode\u003E \u002F the \u003Ccode\u003Eqemu\u003C\u002Fcode\u003E hypervisor\u003C\u002Fli\u003E\n\u003Cli\u003EInstall \u003Ccode\u003Ek3s\u003C\u002Fcode\u003E:\u003Cul\u003E\n\u003Cli\u003Eon server node, then\u003C\u002Fli\u003E\n\u003Cli\u003Eon VM nodes\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch4 id=\"also-a-few-links-to-article-thatve-helped-me-setup-my-rpi-cluster-if-youre-an-author-of-any-of-these-and-you-happen-to-be-reading-this---thank-you\"\u003EAlso, a few links to article that&#39;ve helped me setup my RPi cluster; if you&#39;re an author of any of these and you happen to be reading this - thank you!!!\u003C\u002Fh4\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Faskubuntu.com\u002Fa\u002F1190457\"\u003ESO answer to enabling cgroups\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fblog.alexellis.io\u002Fkvm-kubernetes-primer\u002F\"\u003EGet started with KVM &amp; Kubernetes\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fmanpages.ubuntu.com\u002Fmanpages\u002Feoan\u002Fman1\u002Fvirt-install.1.html#synopsis\"\u003EUbuntu 19.10 manpages - \u003Ccode\u003Evirt-install\u003C\u002Fcode\u003E\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fblog.programster.org\u002Fkvm-cheatsheet\"\u003EKVM Cheatsheet\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fhelp.ubuntu.com\u002Fcommunity\u002FKVM\"\u003EKVM - Ubuntu Community Help Wiki\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.freedesktop.org\u002Fwiki\u002FSoftware\u002Fsystemd\u002FTipsAndTricks\u002F\"\u003E\u003Ccode\u003Esystemd\u003C\u002Fcode\u003E tips and tricks\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Ffabianlee.org\u002F2019\u002F04\u002F01\u002Fkvm-creating-a-bridged-network-with-netplan-on-ubuntu-bionic\u002F\"\u003EKVM: Creating a bridged network with NetPlan on Ubuntu bionic\n\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fvitux.com\u002Fhow-to-configure-networking-with-netplan-on-ubuntu\u002F\"\u003EExplanations of netplan&#39;s yaml config\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch1 id=\"flash-the-sd-card\"\u003EFlash the SD card\u003C\u002Fh1\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fwww.balena.io\u002Fetcher\u002F\"\u003EbalenaEtcher\u003C\u002Fa\u003E is the trick to save some time, use the \u003Ccode\u003Ecli\u003C\u002Fcode\u003E if you really want; boot and setup the RPi node\u003C\u002Fli\u003E\n\u003Cli\u003EI primarily SSH into the Raspberry Pi. Run \u003Ccode\u003Esudo nmap -sP ${your_ip_here}\u002F24\u003C\u002Fcode\u003E to find the IP address of the RPi\u003Cul\u003E\n\u003Cli\u003Enote: \u003Ccode\u003Eubuntu\u003C\u002Fcode\u003E is the default value for both username\u002Fpassword for the fresh Ubuntu install\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch1 id=\"server-node-considerations-before-installing-kubernetes\"\u003EServer node considerations before installing Kubernetes\u003C\u002Fh1\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003Eenable \u003Ccode\u003Ecgroups\u003C\u002Fcode\u003E &amp; \u003Ccode\u003Enamespaces\u003C\u002Fcode\u003E \u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Ethese kernel features are necessary for containerization, in Ubuntu 19.10 for ARM \u002F RPi the file is located at \u003Ccode\u003E\u002Fboot\u002Ffirmware\u002Fnobtcmd.txt\u003C\u002Fcode\u003E. Add the following and reboot: \u003Ccode\u003Ecgroup_enable=cpuset cgroup_enable=memory cgroup_memory=1\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cimg src=\"k3s_screens\u002Fkernel_container_features.png\" alt=\"enable container features\"\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Edisable \u003Ccode\u003Eswap\u003C\u002Fcode\u003E. Kubernetes requires swap memory disabled to run properly, see this \u003Ca href=\"https:\u002F\u002Fdiscuss.kubernetes.io\u002Ft\u002Fswap-off-why-is-it-necessary\u002F6879\"\u003Ediscussion for a high-level explanation\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EUbuntu uses \u003Ca href=\"http:\u002F\u002Fmanpages.ubuntu.com\u002Fmanpages\u002Feoan\u002Fman1\u002Fsystemd.1.html\"\u003E\u003Ccode\u003Esystemd\u003C\u002Fcode\u003E\u003C\u002Fa\u003E to manage various systems and services\u003C\u002Fli\u003E\n\u003Cli\u003Erun \u003Ccode\u003Esudo systemctl --type swap\u003C\u002Fcode\u003E...\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cimg src=\"k3s_screens\u002Fdisable_swap_file.png\" alt=\"disalbe swap\"\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fhelp.ubuntu.com\u002Fcommunity\u002FKVM\u002FInstallation#Install_Necessary_Packages\"\u003E\u003Ccode\u003EKVM\u003C\u002Fcode\u003E \u002F \u003Ccode\u003Eqemu\u003C\u002Fcode\u003E\u003C\u002Fa\u003E tooling must be installed to spinup VMs. After installing the necessary packages, you should be able to run\u002Fsee the following in your terminal\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"k3s_screens\u002Fkvm_ready.png\" alt=\"kvm-ok\"\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003EVMs must exist on a bridged network, the existing network configuration file for our Ubuntu 19.10 system is located at \u003Ccode\u003E\u002Fetc\u002Fnetplan\u002F50-cloud-init.yaml\u003C\u002Fcode\u003E. Before making any changes to the configuration file, \u003Ccode\u003Ecp\u003C\u002Fcode\u003E it to a backup file (believe me)! Now follow the \u003Ca href=\"https:\u002F\u002Ffabianlee.org\u002F2019\u002F04\u002F01\u002Fkvm-creating-a-bridged-network-with-netplan-on-ubuntu-bionic\u002F\"\u003Einstructions here\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Emirror as many details possible in the original \u003Ccode\u003Enetplan\u003C\u002Fcode\u003E config\u003C\u002Fli\u003E\n\u003Cli\u003Eensure \u003Cem\u003Etrying\u003C\u002Fem\u003E the netplan config before applying it, run \u003Ccode\u003Esudo netplan generate\u003C\u002Fcode\u003E. All the details are in Fabian&#39;s guide\u003Cul\u003E\n\u003Cli\u003Ealso ensure the KVM guests will get access to the bridge by passing \u003Ca href=\"https:\u002F\u002Fnetplan.io\u002Fexamples#configuring-network-bridges\"\u003E\u003Ccode\u003Elibvirt\u003C\u002Fcode\u003E an \u003Ccode\u003Exml\u003C\u002Fcode\u003E representation\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch1 id=\"install-a-few-vms\"\u003EInstall a few VMs\u003C\u002Fh1\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"http:\u002F\u002Fmanpages.ubuntu.com\u002Fmanpages\u002Feoan\u002Fman1\u002Fvirt-install.1.html#examples\"\u003ESee the \u003Ccode\u003Evirt-install\u003C\u002Fcode\u003E examples\u003C\u002Fa\u003E from the Ubuntu 19.10 manpages for a quick tour of creating a new KVM guest. Also, feel free to use the bash script below.\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Esudo virt-install \\\n--name $1 \\\n--memory 1024 \\\n--disk size=3.5 \\\n--vcpus 1 \\\n--os-type generic \\\n--graphics none \\\n--cdrom $2\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003Ewhere the first arg, \u003Ccode\u003E$1\u003C\u002Fcode\u003E, will be the name of the KVM guest, and the second will be the \u003Ccode\u003E.iso\u003C\u002Fcode\u003E image to install the guest OS. I recommend \u003Ca href=\"http:\u002F\u002Fcdimage.ubuntu.com\u002Fubuntu\u002Freleases\u002F19.10\u002Frelease\u002Fubuntu-19.10-server-arm64.iso\"\u003Eubuntu-19.10-server-arm64.iso\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003Eduring install, I opt to partition the drive as &#39;Guided, use entire disk&#39;\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\"k3s_screens\u002Fuse_entire_disk.png\" alt=\"entire disk\"\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Enote: \u003Cstrong\u003Eplease\u003C\u002Fstrong\u003E do yourself a favour and make a secure record of your RPi, and KVM Guest usernames &amp; passwords.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Cem\u003Eremember to handle\u003C\u002Fem\u003E \u003Ccode\u003Eswap\u003C\u002Fcode\u003E for your VMs\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Econfirm your KVM guests via \u003Ccode\u003Evirsh list --all\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch1 id=\"install-kubernetes-via-k3s\"\u003EInstall Kubernetes via \u003Ccode\u003Ek3s\u003C\u002Fcode\u003E\u003C\u002Fh1\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ca href=\"https:\u002F\u002Fk3s.io\"\u003Ek3s.io\u003C\u002Fa\u003E is the best source for walking through \u003Ccode\u003Ek3s\u003C\u002Fcode\u003E installation. Install \u003Ccode\u003Ek3s\u003C\u002Fcode\u003E on your RPi to become the server node with the following: \u003Ccode\u003Ecurl -sfL https:\u002F\u002Fget.k3s.io | sh -s - --write-kubeconfig-mode 644\u003C\u002Fcode\u003E. \u003Ccode\u003E664\u003C\u002Fcode\u003E ensures you have permissions to access the cluster&#39;s kube config file without the use of \u003Ccode\u003Esudo\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003Ebecause we&#39;ve enabled container features, and ensured \u003Ccode\u003Eswap\u003C\u002Fcode\u003E is off, our \u003Ccode\u003Ek3s\u003C\u002Fcode\u003E install should have worked for our server node. To be able to join our KVM guests as worker nodes, we&#39;ll need to capture two items off our server:\u003Cul\u003E\n\u003Cli\u003Ethe \u003Ccode\u003Ek3s\u003C\u002Fcode\u003E server token, stored at \u003Ccode\u003E\u002Fvar\u002Flib\u002Francher\u002Fk3s\u002Fserver\u002Fnode-token\u003C\u002Fcode\u003E, and the IP address of your RPi (which likely have already from configuring SSH access, otherwise run \u003Ccode\u003Eip addr | grep inet\u003C\u002Fcode\u003E and look for the address beginning along the lines of \u003Ccode\u003E192.168\u003C\u002Fcode\u003E...).\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003Eto join our worker node, we need to login to it. We can do so via \u003Ccode\u003Evirsh console $GUEST_NAME\u003C\u002Fcode\u003E. Once in, we run the call to the \u003Ccode\u003Ek3s\u003C\u002Fcode\u003E installer; however the flags will be different. The worker node install makes reference to the server IP address, and server token. E.g.:\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Ecurl -sfL https:\u002F\u002Fget.k3s.io | K3S_URL=https:\u002F\u002F$SERVER_IP:6443 \\\n&gt; K3S_TOKEN=$SERVER_TOKEN sh -\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"if-alls-gone-well-youve-setup-a-proper-kubernets-cluster-with-just-one-raspberry-pi-board\"\u003EIf all&#39;s gone well, you&#39;ve setup a proper Kubernets cluster with just one Raspberry Pi board!\u003C\u002Fh2\u003E\n\u003Cp\u003E  \u003Cimg src=\"k3s_screens\u002Fcluster_running.png\" alt=\"cluster running\"\u003E\u003C\u002Fp\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.2795d7ba.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main","/client/client.2795d7ba.js")}document.head.appendChild(s)</script> <style>img{max-width:100%;height:auto}p{font-size:1.125rem}</style> <title>Creating a multinode Kubernetes cluster from a single Raspberry Pi 4</title> <link href=/client/[slug].e84058df.css rel=preload as=style></head> <body class=container> <div class="row mb-3"><h1 class=col-6>Creating a multinode Kubernetes cluster from a single Raspberry Pi 4</h1></div> <div class=row><article class="col-11 text-normal"><h1 id=setup-a-kubernetes-cluster-on-a-single-raspberry-pi-4-using-kvm-and-k3s>Setup a Kubernetes cluster on a single Raspberry Pi 4, using <code>KVM</code> and <code>k3s</code></h1> <h3 id=not-all-tools-just-work-for-soc-systems>Not all tools 'just work' for SoC systems</h3> <p>Having decided to learn Kubernetes, I purchased a Rasperry Pi 4 (4GB) to create a dedicated machine / cluster to experiment and learn on. I <em>figured</em> I could use a simple tool to create a few VMs, and create a trivial cluster; however <code>multipass</code> would not spin up VMs on my Pi. I didn't want to buy another Pi, so I started down the path of creating worker nodes via KVM/QEMU.</p> <p>I'd like to share the steps I've taken to create (<em>technically</em>, perhaps not practically) a Kubernetes cluster with only one Raspberry Pi board.</p> <h3 id=these-are-the-required-steps-at-a-high-level>These are the required steps, at a high level</h3> <ol> <li>Flash a Micro SD card with Ubuntu Server 19.10 for <a href=http://old-releases.ubuntu.com/releases/19.10/ubuntu-19.10-preinstalled-server-arm64+raspi3.img.xz>Raspberry Pi</a></li> <li>Set up the server node (the Raspberry Pi itself)</li> <li>Handle k8s-related considerations for the server node<ul> <li>virtualization, container features, bridged networking</li> </ul> </li> <li>Install VMs via <code>virt-install</code> / the <code>qemu</code> hypervisor</li> <li>Install <code>k3s</code>:<ul> <li>on server node, then</li> <li>on VM nodes</li> </ul> </li> </ol> <h4 id=also-a-few-links-to-article-thatve-helped-me-setup-my-rpi-cluster-if-youre-an-author-of-any-of-these-and-you-happen-to-be-reading-this---thank-you>Also, a few links to article that've helped me setup my RPi cluster; if you're an author of any of these and you happen to be reading this - thank you!!!</h4> <ul> <li><a href=https://askubuntu.com/a/1190457>SO answer to enabling cgroups</a></li> <li><a href=https://blog.alexellis.io/kvm-kubernetes-primer/ >Get started with KVM & Kubernetes</a></li> <li><a href=http://manpages.ubuntu.com/manpages/eoan/man1/virt-install.1.html#synopsis>Ubuntu 19.10 manpages - <code>virt-install</code></a></li> <li><a href=https://blog.programster.org/kvm-cheatsheet>KVM Cheatsheet</a></li> <li><a href=https://help.ubuntu.com/community/KVM>KVM - Ubuntu Community Help Wiki</a></li> <li><a href=https://www.freedesktop.org/wiki/Software/systemd/TipsAndTricks/ ><code>systemd</code> tips and tricks</a></li> <li><a href=https://fabianlee.org/2019/04/01/kvm-creating-a-bridged-network-with-netplan-on-ubuntu-bionic/ >KVM: Creating a bridged network with NetPlan on Ubuntu bionic </a></li> <li><a href=https://vitux.com/how-to-configure-networking-with-netplan-on-ubuntu/ >Explanations of netplan's yaml config</a></li> </ul> <h1 id=flash-the-sd-card>Flash the SD card</h1> <ul> <li><a href=https://www.balena.io/etcher/ >balenaEtcher</a> is the trick to save some time, use the <code>cli</code> if you really want; boot and setup the RPi node</li> <li>I primarily SSH into the Raspberry Pi. Run <code>sudo nmap -sP ${your_ip_here}/24</code> to find the IP address of the RPi<ul> <li>note: <code>ubuntu</code> is the default value for both username/password for the fresh Ubuntu install</li> </ul> </li> </ul> <h1 id=server-node-considerations-before-installing-kubernetes>Server node considerations before installing Kubernetes</h1> <ul> <li><p>enable <code>cgroups</code> & <code>namespaces</code> </p> <ul> <li>these kernel features are necessary for containerization, in Ubuntu 19.10 for ARM / RPi the file is located at <code>/boot/firmware/nobtcmd.txt</code>. Add the following and reboot: <code>cgroup_enable=cpuset cgroup_enable=memory cgroup_memory=1</code></li> </ul> <p><img alt="enable container features" src=k3s_screens/kernel_container_features.png></p> </li> <li><p>disable <code>swap</code>. Kubernetes requires swap memory disabled to run properly, see this <a href=https://discuss.kubernetes.io/t/swap-off-why-is-it-necessary/6879>discussion for a high-level explanation</a></p> <ul> <li>Ubuntu uses <a href=http://manpages.ubuntu.com/manpages/eoan/man1/systemd.1.html><code>systemd</code></a> to manage various systems and services</li> <li>run <code>sudo systemctl --type swap</code>...</li> </ul> <p><img alt="disalbe swap" src=k3s_screens/disable_swap_file.png></p> </li> <li><p><a href=https://help.ubuntu.com/community/KVM/Installation#Install_Necessary_Packages><code>KVM</code> / <code>qemu</code></a> tooling must be installed to spinup VMs. After installing the necessary packages, you should be able to run/see the following in your terminal</p> <p><img alt=kvm-ok src=k3s_screens/kvm_ready.png></p> </li> <li><p>VMs must exist on a bridged network, the existing network configuration file for our Ubuntu 19.10 system is located at <code>/etc/netplan/50-cloud-init.yaml</code>. Before making any changes to the configuration file, <code>cp</code> it to a backup file (believe me)! Now follow the <a href=https://fabianlee.org/2019/04/01/kvm-creating-a-bridged-network-with-netplan-on-ubuntu-bionic/ >instructions here</a></p> <ul> <li>mirror as many details possible in the original <code>netplan</code> config</li> <li>ensure <em>trying</em> the netplan config before applying it, run <code>sudo netplan generate</code>. All the details are in Fabian's guide<ul> <li>also ensure the KVM guests will get access to the bridge by passing <a href=https://netplan.io/examples#configuring-network-bridges><code>libvirt</code> an <code>xml</code> representation</a></li> </ul> </li> </ul> </li> </ul> <h1 id=install-a-few-vms>Install a few VMs</h1> <ul> <li><a href=http://manpages.ubuntu.com/manpages/eoan/man1/virt-install.1.html#examples>See the <code>virt-install</code> examples</a> from the Ubuntu 19.10 manpages for a quick tour of creating a new KVM guest. Also, feel free to use the bash script below.<pre><code class=language-bash>sudo virt-install \
--name $1 \
--memory 1024 \
--disk size=3.5 \
--vcpus 1 \
--os-type generic \
--graphics none \
--cdrom $2</code></pre> </li> </ul> <p>where the first arg, <code>$1</code>, will be the name of the KVM guest, and the second will be the <code>.iso</code> image to install the guest OS. I recommend <a href=http://cdimage.ubuntu.com/ubuntu/releases/19.10/release/ubuntu-19.10-server-arm64.iso>ubuntu-19.10-server-arm64.iso</a></p> <ul> <li><p>during install, I opt to partition the drive as 'Guided, use entire disk'</p> <p><img alt="entire disk" src=k3s_screens/use_entire_disk.png></p> </li> <li><p>note: <strong>please</strong> do yourself a favour and make a secure record of your RPi, and KVM Guest usernames & passwords.</p> </li> <li><p><em>remember to handle</em> <code>swap</code> for your VMs</p> </li> <li><p>confirm your KVM guests via <code>virsh list --all</code></p> </li> </ul> <h1 id=install-kubernetes-via-k3s>Install Kubernetes via <code>k3s</code></h1> <ul> <li><a href=https://k3s.io>k3s.io</a> is the best source for walking through <code>k3s</code> installation. Install <code>k3s</code> on your RPi to become the server node with the following: <code>curl -sfL https://get.k3s.io | sh -s - --write-kubeconfig-mode 644</code>. <code>664</code> ensures you have permissions to access the cluster's kube config file without the use of <code>sudo</code></li> <li>because we've enabled container features, and ensured <code>swap</code> is off, our <code>k3s</code> install should have worked for our server node. To be able to join our KVM guests as worker nodes, we'll need to capture two items off our server:<ul> <li>the <code>k3s</code> server token, stored at <code>/var/lib/rancher/k3s/server/node-token</code>, and the IP address of your RPi (which likely have already from configuring SSH access, otherwise run <code>ip addr | grep inet</code> and look for the address beginning along the lines of <code>192.168</code>...).</li> </ul> </li> <li>to join our worker node, we need to login to it. We can do so via <code>virsh console $GUEST_NAME</code>. Once in, we run the call to the <code>k3s</code> installer; however the flags will be different. The worker node install makes reference to the server IP address, and server token. E.g.:<pre><code class=language-bash>curl -sfL https://get.k3s.io | K3S_URL=https://$SERVER_IP:6443 \
> K3S_TOKEN=$SERVER_TOKEN sh -</code></pre> </li> </ul> <h2 id=if-alls-gone-well-youve-setup-a-proper-kubernets-cluster-with-just-one-raspberry-pi-board>If all's gone well, you've setup a proper Kubernets cluster with just one Raspberry Pi board!</h2> <p> <img alt="cluster running" src=k3s_screens/cluster_running.png></p> </article></div> 