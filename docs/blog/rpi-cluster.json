{"title":"Creating a multinode Kubernetes cluster from a single Raspberry Pi 4","slug":"rpi-cluster","html":"<h1 id=\"setup-a-kubernetes-cluster-on-a-single-raspberry-pi-4-using-kvm-and-k3s\">Setup a Kubernetes cluster on a single Raspberry Pi 4, using <code>KVM</code> and <code>k3s</code></h1>\n<h3 id=\"not-all-tools-just-work-for-soc-systems\">Not all tools &#39;just work&#39; for SoC systems</h3>\n<p>Having decided to learn Kubernetes, I purchased a Rasperry Pi 4 (4GB) to create a dedicated machine / cluster to experiment and learn on. I <em>figured</em> I could use a simple tool to create a few VMs, and create a trivial cluster; however <code>multipass</code> would not spin up VMs on my Pi. I didn&#39;t want to buy another Pi, so I started down the path of creating worker nodes via KVM/QEMU.</p>\n<p>I&#39;d like to share the steps I&#39;ve taken to create (<em>technically</em>, perhaps not practically) a Kubernetes cluster with only one Raspberry Pi board.</p>\n<h3 id=\"these-are-the-required-steps-at-a-high-level\">These are the required steps, at a high level</h3>\n<ol>\n<li>Flash a Micro SD card with Ubuntu Server 19.10 for <a href=\"http://old-releases.ubuntu.com/releases/19.10/ubuntu-19.10-preinstalled-server-arm64+raspi3.img.xz\">Raspberry Pi</a></li>\n<li>Set up the server node (the Raspberry Pi itself)</li>\n<li>Handle k8s-related considerations for the server node<ul>\n<li>virtualization, container features, bridged networking</li>\n</ul>\n</li>\n<li>Install VMs via <code>virt-install</code> / the <code>qemu</code> hypervisor</li>\n<li>Install <code>k3s</code>:<ul>\n<li>on server node, then</li>\n<li>on VM nodes</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"also-a-few-links-to-article-thatve-helped-me-setup-my-rpi-cluster-if-youre-an-author-of-any-of-these-and-you-happen-to-be-reading-this---thank-you\">Also, a few links to article that&#39;ve helped me setup my RPi cluster; if you&#39;re an author of any of these and you happen to be reading this - thank you!!!</h4>\n<ul>\n<li><a href=\"https://askubuntu.com/a/1190457\">SO answer to enabling cgroups</a></li>\n<li><a href=\"https://blog.alexellis.io/kvm-kubernetes-primer/\">Get started with KVM &amp; Kubernetes</a></li>\n<li><a href=\"http://manpages.ubuntu.com/manpages/eoan/man1/virt-install.1.html#synopsis\">Ubuntu 19.10 manpages - <code>virt-install</code></a></li>\n<li><a href=\"https://blog.programster.org/kvm-cheatsheet\">KVM Cheatsheet</a></li>\n<li><a href=\"https://help.ubuntu.com/community/KVM\">KVM - Ubuntu Community Help Wiki</a></li>\n<li><a href=\"https://www.freedesktop.org/wiki/Software/systemd/TipsAndTricks/\"><code>systemd</code> tips and tricks</a></li>\n<li><a href=\"https://fabianlee.org/2019/04/01/kvm-creating-a-bridged-network-with-netplan-on-ubuntu-bionic/\">KVM: Creating a bridged network with NetPlan on Ubuntu bionic\n</a></li>\n<li><a href=\"https://vitux.com/how-to-configure-networking-with-netplan-on-ubuntu/\">Explanations of netplan&#39;s yaml config</a></li>\n</ul>\n<h1 id=\"flash-the-sd-card\">Flash the SD card</h1>\n<ul>\n<li><a href=\"https://www.balena.io/etcher/\">balenaEtcher</a> is the trick to save some time, use the <code>cli</code> if you really want; boot and setup the RPi node</li>\n<li>I primarily SSH into the Raspberry Pi. Run <code>sudo nmap -sP ${your_ip_here}/24</code> to find the IP address of the RPi<ul>\n<li>note: <code>ubuntu</code> is the default value for both username/password for the fresh Ubuntu install</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"server-node-considerations-before-installing-kubernetes\">Server node considerations before installing Kubernetes</h1>\n<ul>\n<li><p>enable <code>cgroups</code> &amp; <code>namespaces</code> </p>\n<ul>\n<li>these kernel features are necessary for containerization, in Ubuntu 19.10 for ARM / RPi the file is located at <code>/boot/firmware/nobtcmd.txt</code>. Add the following and reboot: <code>cgroup_enable=cpuset cgroup_enable=memory cgroup_memory=1</code></li>\n</ul>\n<p><img src=\"k3s_screens/kernel_container_features.png\" alt=\"enable container features\"></p>\n</li>\n<li><p>disable <code>swap</code>. Kubernetes requires swap memory disabled to run properly, see this <a href=\"https://discuss.kubernetes.io/t/swap-off-why-is-it-necessary/6879\">discussion for a high-level explanation</a></p>\n<ul>\n<li>Ubuntu uses <a href=\"http://manpages.ubuntu.com/manpages/eoan/man1/systemd.1.html\"><code>systemd</code></a> to manage various systems and services</li>\n<li>run <code>sudo systemctl --type swap</code>...</li>\n</ul>\n<p><img src=\"k3s_screens/disable_swap_file.png\" alt=\"disalbe swap\"></p>\n</li>\n<li><p><a href=\"https://help.ubuntu.com/community/KVM/Installation#Install_Necessary_Packages\"><code>KVM</code> / <code>qemu</code></a> tooling must be installed to spinup VMs. After installing the necessary packages, you should be able to run/see the following in your terminal</p>\n<p><img src=\"k3s_screens/kvm_ready.png\" alt=\"kvm-ok\"></p>\n</li>\n<li><p>VMs must exist on a bridged network, the existing network configuration file for our Ubuntu 19.10 system is located at <code>/etc/netplan/50-cloud-init.yaml</code>. Before making any changes to the configuration file, <code>cp</code> it to a backup file (believe me)! Now follow the <a href=\"https://fabianlee.org/2019/04/01/kvm-creating-a-bridged-network-with-netplan-on-ubuntu-bionic/\">instructions here</a></p>\n<ul>\n<li>mirror as many details possible in the original <code>netplan</code> config</li>\n<li>ensure <em>trying</em> the netplan config before applying it, run <code>sudo netplan generate</code>. All the details are in Fabian&#39;s guide<ul>\n<li>also ensure the KVM guests will get access to the bridge by passing <a href=\"https://netplan.io/examples#configuring-network-bridges\"><code>libvirt</code> an <code>xml</code> representation</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"install-a-few-vms\">Install a few VMs</h1>\n<ul>\n<li><a href=\"http://manpages.ubuntu.com/manpages/eoan/man1/virt-install.1.html#examples\">See the <code>virt-install</code> examples</a> from the Ubuntu 19.10 manpages for a quick tour of creating a new KVM guest. Also, feel free to use the bash script below.<pre><code class=\"language-bash\">sudo virt-install \\\n--name $1 \\\n--memory 1024 \\\n--disk size=3.5 \\\n--vcpus 1 \\\n--os-type generic \\\n--graphics none \\\n--cdrom $2</code></pre>\n</li>\n</ul>\n<p>where the first arg, <code>$1</code>, will be the name of the KVM guest, and the second will be the <code>.iso</code> image to install the guest OS. I recommend <a href=\"http://cdimage.ubuntu.com/ubuntu/releases/19.10/release/ubuntu-19.10-server-arm64.iso\">ubuntu-19.10-server-arm64.iso</a></p>\n<ul>\n<li><p>during install, I opt to partition the drive as &#39;Guided, use entire disk&#39;</p>\n<p><img src=\"k3s_screens/use_entire_disk.png\" alt=\"entire disk\"></p>\n</li>\n<li><p>note: <strong>please</strong> do yourself a favour and make a secure record of your RPi, and KVM Guest usernames &amp; passwords.</p>\n</li>\n<li><p><em>remember to handle</em> <code>swap</code> for your VMs</p>\n</li>\n<li><p>confirm your KVM guests via <code>virsh list --all</code></p>\n</li>\n</ul>\n<h1 id=\"install-kubernetes-via-k3s\">Install Kubernetes via <code>k3s</code></h1>\n<ul>\n<li><a href=\"https://k3s.io\">k3s.io</a> is the best source for walking through <code>k3s</code> installation. Install <code>k3s</code> on your RPi to become the server node with the following: <code>curl -sfL https://get.k3s.io | sh -s - --write-kubeconfig-mode 644</code>. <code>664</code> ensures you have permissions to access the cluster&#39;s kube config file without the use of <code>sudo</code></li>\n<li>because we&#39;ve enabled container features, and ensured <code>swap</code> is off, our <code>k3s</code> install should have worked for our server node. To be able to join our KVM guests as worker nodes, we&#39;ll need to capture two items off our server:<ul>\n<li>the <code>k3s</code> server token, stored at <code>/var/lib/rancher/k3s/server/node-token</code>, and the IP address of your RPi (which likely have already from configuring SSH access, otherwise run <code>ip addr | grep inet</code> and look for the address beginning along the lines of <code>192.168</code>...).</li>\n</ul>\n</li>\n<li>to join our worker node, we need to login to it. We can do so via <code>virsh console $GUEST_NAME</code>. Once in, we run the call to the <code>k3s</code> installer; however the flags will be different. The worker node install makes reference to the server IP address, and server token. E.g.:<pre><code class=\"language-bash\">curl -sfL https://get.k3s.io | K3S_URL=https://$SERVER_IP:6443 \\\n&gt; K3S_TOKEN=$SERVER_TOKEN sh -</code></pre>\n</li>\n</ul>\n<h2 id=\"if-alls-gone-well-youve-setup-a-proper-kubernets-cluster-with-just-one-raspberry-pi-board\">If all&#39;s gone well, you&#39;ve setup a proper Kubernets cluster with just one Raspberry Pi board!</h2>\n<p>  <img src=\"k3s_screens/cluster_running.png\" alt=\"cluster running\"></p>\n"}